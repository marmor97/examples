---
title: "Assignment 4 - Heart rate, respiration and interpersonal coordination"
author: "Riccardo Fusaroli"
date: "August 20, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Assignment 4 - Heart rate, respiration and interpersonal coordination

Physiological data (here heart rate [variability], and respiration) are increasingly popular. Historically treated as pernicious noise to be regressed out of neuro-imaging data, there is now increasing research on how these signals tell us something important about cognition and beyond being just a signal of cognitive processes also impact them in interesting ways. Advanced sport science, and the quantified self movement (closely followed by marketing and communication) have hailed continuous physiological tracking as a powerful way to access and modify attitudes, habits, and performance. Further, as team coordination (in the military, in decision processes and organizational contexts) is more and more in focus, research has attempted to measure how interpersonal coordination between physiological systems might tell us something important about e.g. emotional and cognitive coordination. See references in the reading list for more on this.

In this assignment, you will learn to:
- collect physiological data
- pre-process physiological data (and grow further your mad R skills)
- model the continuous interdependence between two signals (using a multilevel model as proxy for a dynamical system approach)
- conservatively assess the presence of coordination between to signals in a controlled context

This assignment has two parts. The first part familiarizes you with heart rate, and respiration data and their preprocessing. The second part explores how to analyze interpersonal coordination of these signals.

These are the questions you need to be able to answer at the end of the assignment (aka that you need to submit as part of the portfolio)

1) How do you preprocess heart rate and respiration data? Describe the process. If any data needs to be excluded, list the excluded data and motivate the exclusion.

2) Do you observe interpersonal coordination in heart rate and respiration? Describe your control baseline, the method used to quantify coordination, and the statistical models used to infer whether coordination was higher than in the baseline. Report the results of the models.

3) Do you observe differences in coordination between conditions? Report the models and results.

4) Is respiration coordination a likely driver of heart rate coordination? Describe how you would test for it. Bonus points if you actually run the tests and report methods and results.

N.B. to give you a bit more data I included data from previous years (Study1, Study2 and Study 3). Note that synchronouns and turn-taking are the same across both studies, but the third condition is different: in the first year it was self-paced joint reading; in the second year it was the tv-series conversation.

## Let's get started

### Exploring physiological signals

- Choose one pair (one pair, three conditions)
- Load the logs
- Produce a plot of the participants' respiration signal and a different one of the participants' HR signal.
  N.B: remember the slides: artifacts, downsampling, scaling.
  N.B. The gridExtra::grid.arrange() function allows you to display the plots side by side. E.g. grid.arrange(plot1, plot2, plot3, ncol=3). There are also smarter packages, like cowplot and ggpubr.
- Can you eye-ball which condition if any displays more physiological coordination?

### First we read one data file and identify the procedure
- Load the file
- correctly identify all columns
- plot the data
- deal with the artifacts
- downsample the dat
- Add a column for study, group, trial and condition



Libaries
```{r}
## Load the libraries
library(pacman)
p_load(tidyverse, stringr, dplyr, purrr, lme4, lmerTest, magrittr, tidymodels, boot, rsample, caret, e1071, pROC, groupdata2, Metrics, ggplot2, stats)

```

Preprocessing on single file
```{r}
## Load the files
synchro <- read.csv("data/Study4_G4_T3_Synchronous.csv")
conv <- read.csv("data/Study4_G4_T4_Conversation.csv")
turn <- read.csv("data/Study4_G4_T5_TurnTaking.csv")

## Remove outliers

removeOuts <- function(ts,threshold){
  ts[ts > (mean(ts,na.rm=T) +
             (threshold*sd(ts,na.rm=T))) | 
       ts < (mean(ts,na.rm=T) -
             (threshold*sd(ts,na.rm=T)))] = mean(ts,na.rm=T)
  return(ts)
}
threshold=2 # Default value at 2.5 sds from the mean - we changed it to 2

synchro$HR1_clean <-removeOuts(synchro$HR1, 2)
synchro$HR2_clean <-removeOuts(synchro$HR2, 2)

synchro$Resp1_clean <-removeOuts(synchro$Resp1, 2)
synchro$Resp2_clean <-removeOuts(synchro$Resp2, 2)

## Plot raw data againt those with the artiacts removed

#heart
#heart_plot3 <- ggplot(synchro, aes(min, HR1_clean)) + geom_line() 
#heart_plot4 <- ggplot(synchro, aes(min, HR2_clean)) + geom_line() 

#gridExtra::grid.arrange(heart_plot1, heart_plot3)
#gridExtra::grid.arrange(heart_plot2, heart_plot4)

#resp
#resp_plot3 <- ggplot(synchro, aes(min, Resp1_clean)) + geom_line() 
#resp_plot4 <- ggplot(synchro, aes(min, Resp2_clean)) + geom_line() 

#gridExtra::grid.arrange(resp_plot1, resp_plot3)
#gridExtra::grid.arrange(resp_plot2, resp_plot4)


## Scale
#Tip: if scale() gives some issues, try the one below
#z_scale <- function(column){
#  column_c <- (column - mean(column)) / sd(column)
#}

synchro <- synchro %>% mutate_at(c("HR1_clean", "HR2_clean", "Resp1_clean", "Resp2_clean"), scale) #na.rm=TRUE

## Plot again to check how scaled data look like

#plot5 <- ggplot(scale_sync, aes(min, HR1_clean)) + geom_line() 
#plot6 <- ggplot(scale_sync, aes(min, HR2_clean)) + geom_line() 
  
#gridExtra::grid.arrange(plot3, plot5)
#gridExtra::grid.arrange(plot4, plot6)


## Downsample

synchro$rowname <- c(1:nrow(synchro))

down = synchro %>%
  group(n = 100, method = 'greedy') %>%
  dplyr::summarise(
    time = mean(TimeMs,na.rm=T),
    HR1 = mean(HR1_clean,na.rm=T),
    HR2 = mean(HR2_clean,na.rm=T),
    Resp1 = mean(Resp1_clean,na.rm=T),
    Resp2 = mean(Resp2_clean,na.rm=T),
    rowname = rowname[1]) #the index we use to put them back together 


## Plot the downsampled data
plotty_resp <- ggplot(data = down) +
  geom_path(aes(time, Resp1, color = "P1")) +
  geom_path(aes(time, Resp2, color = "P2")) +
  labs(x = "time", y = "Resp") +
  theme(legend.position="bottom")
plotty_resp

plotty_heart <- ggplot(data = down) +
  geom_path(aes(time, HR1, color = "P1")) +
  geom_path(aes(time, HR2, color = "P2")) +
  labs(x = "time", y = "HR") +
  theme(legend.position="bottom")
plotty_heart

## Now add the group, trial, condition to the cleaned up, scaled, downsampled data
## Tip the info is in the file name

```

## Now we are ready to go to load and pre-process all files

Go through all the files (with a function passed onto map_df), check which files should be excluded, if any, and save the pre-processed time-series

A couple of tips:
- looping is oh so slow. Making a function and using Map/Map_df is your salvation.
- each study restarts the group numbering, so you should make sure to change that (e.g. 100 * Study + Group)
- you need to make sure all the data are meaningful or something has to be removed. Plotting is your friend. E.g. "Study1_G1_T1_Synchronous" has one bad respiration signal. We could replace it with NAs


Function
```{r}
## Define a function running the loading, artifact removal, scaling, downsampling, info adding.
## Identify all files to be read
## Run the function on the whole dataset using map_df

#creating function for removing outliers
removeOuts <- function(ts,threshold){
  ts[ts > (mean(ts,na.rm=T) +
             (threshold*sd(ts,na.rm=T))) | 
       ts < (mean(ts,na.rm=T) -
             (threshold*sd(ts,na.rm=T)))] = mean(ts,na.rm=T)
  return(ts)
}
threshold=2 # Default value at 2.5 sds from the mean - we changed it to 2

#creating great function
myfunction <- function(filename) {
    # load data
    data <- read.csv(paste("data/",filename, sep = ""), sep = ",")
    list <- str_extract_all(filename, ".")
    
    #outliers
    data$HR1_clean <-removeOuts(data$HR1, 2)
    data$HR2_clean <-removeOuts(data$HR2, 2)
    
    data$Resp1_clean <-removeOuts(data$Resp1, 2)
    data$Resp2_clean <-removeOuts(data$Resp2, 2)
    
    #scale
    data <- data %>% mutate_at(c("HR1_clean", "HR2_clean", "Resp1_clean", "Resp2_clean"), scale)
    
    #downsample
    data$rowname <- c(1:nrow(data))
    
    if (substr(filename,6,6) == "4") { #if 6th element of filename is 4 (study 4) then time column is 'timeMS'
    data = data %>%
      group(n = 1000, method = 'greedy') %>%
      dplyr::summarise(
        time = mean(TimeMs,na.rm=T),
        HR1 = mean(HR1_clean,na.rm=T),
        HR2 = mean(HR2_clean,na.rm=T),
        Resp1 = mean(Resp1_clean,na.rm=T),
        Resp2 = mean(Resp2_clean,na.rm=T),
        rowname = rowname[1]) #the index we use to put them back together 

    } else {                          #if not 4 then time column should be made from 'time'
    data = data %>%
      group(n = 1000, method = 'greedy') %>%
      dplyr::summarise(
        time = mean(time,na.rm=T),
        HR1 = mean(HR1_clean,na.rm=T),
        HR2 = mean(HR2_clean,na.rm=T),
        Resp1 = mean(Resp1_clean,na.rm=T),
        Resp2 = mean(Resp2_clean,na.rm=T),
        rowname = rowname[1]) #the index we use to put them back together 
    }

    # parse filename to extract study, diagnosis, subject and trial
    data$study <- list[[1]][6]
    data$group <- list[[1]][9]
    data$trial <- list[[1]][12]
    data$condition1 <- list[[1]][14] #because there are 2 conditions that starts with same letter ...
    data$condition2 <- list[[1]][15] #we take both first and second letter but in seperate columns
    data$filename <- filename
    # combine all this data in one dataset
    return(data)

}

datty$condition <- paste(datty$condition1, datty$condition2) #making condition columns into one column


#testing on one participant
#test <- myfunction("Study1_G1_T1_Synchronous.csv")

#running function on all data
datty <- list.files(path = "data/", pattern = ".csv") %>% 
    purrr::map_df(myfunction)

write_csv(datty, "big_datty.csv")
datty <- read_csv("big_datty.csv")

#write_csv(fake_datty, "fake_datty.csv") #100 downsample
#fake_datty <- read_csv("fake_datty.csv") #100 downsample

#plots plots plots
dattys_resp_plot <- ggplot(data = datty) +
  geom_path(aes(time, Resp1, color = "P1")) +
  geom_path(aes(time, Resp2, color = "P2")) +
  labs(x = "time", y = "Resp") +
  theme(legend.position = "bottom")
dattys_resp_plot

dattys_heart_plot <- ggplot(data = datty) +
  geom_path(aes(time, HR1, color = "P1")) +
  geom_path(aes(time, HR2, color = "P2")) +
  labs(x = "time", y = "Resp") + 
  theme(legend.position="none")
dattys_heart_plot


```


Removing bad data
```{r}
## Now we need to make sure all the data are meaningful or something has to be removed. 
## E.g. "Study1_G1_T1_Synchronous" has one bad respiration signal. We could replace it with NAs
## Remove bad data

#creating dataframe with only study 4
datty <- filter(datty, study == "4")

#plotting to check for bad data (evt. plot fake_datty (100 downsample) instead)
for(i in as.character(levels(as.factor(datty$filename)))){

  stepdatty <- filter(datty, filename == i)
  
  plot <- ggplot(data = stepdatty) +
    geom_path(aes(time, Resp1, color = "P1")) +
    geom_path(aes(time, Resp2, color = "P2")) +
    labs(x = "time", y = "Resp") +
    theme(legend.position = "bottom")+
    ggtitle(as.character(i))
  
   plot2 <- ggplot(data = stepdatty) +
    geom_path(aes(time, HR1, color = "P1")) +
    geom_path(aes(time, HR2, color = "P2")) +
    labs(x = "time", y = "HR") +
    theme(legend.position = "bottom")+
    ggtitle(as.character(i))
   
  gridExtra::grid.arrange(plot,plot2)
  
}

#turning bad values into NAs
datty$HR1[datty$filename == "Study4_G7_T1_MovementGuided.csv"] <- NA
datty$HR2[datty$filename == "Study4_G7_T1_MovementGuided.csv"] <- NA

datty$HR1[datty$filename == "Study4_G7_T2_MovementCoop.csv"] <- NA
datty$HR2[datty$filename == "Study4_G7_T2_MovementCoop.csv"] <- NA

datty$Resp1[datty$filename == "Study4_G4_T5_TurnTaking.csv"] <- NA
datty$Resp2[datty$filename == "Study4_G4_T5_TurnTaking.csv"] <- NA

datty$Resp1[datty$filename == "Study4_G1_T1_Synchronous.csv"] <- NA
datty$Resp2[datty$filename == "Study4_G1_T1_Synchronous.csv"] <- NA

```



## Now we need to run some analysis

Let's start with a multilevel model that accounts for 
- stability (how each signal is autocorrelated)
- interpersonal dependence (each signal is dependent from the previous state of the other signal)

The data needs to be further prepared, so we can analyze both participants in the same model.
We need to turn the data into a long format:
- a column indicating own hr and one own respiration
- a column indicating other hr and one other respiration
- a column indicating change in hr from previous round and one in respiration

We can then run an analysis where change is a function of one's previous state (stability, see slides), and the other's previous state (coupling). Make sure to:
- set up the most interesting contrasts: how do these parameters vary by condition? which condition should be baseline?
- set up the right random effects.
- N.B. the model will be slow. Make sure it works on a subset of the data first!

Bonus question: what if we include an additional layer? Is my heart rate just adjusting to yours, or also to how much you are adjusting to mine?
- to start answering this we can add a column indicating the previous change in hr in the other and one in respiration
- we can then build on the previous models by also adding the previous change in the other

Notes
```{r}
# Genearate a column for each: previous HR1, HR2, Resp1, Resp2
# Genearate a column for each: change in HR1, HR2, Resp1, Resp2
# Make the data long, so we can analyze both participants at the same time 
## N.B. This is a bit tricky and you might have to do it in several steps
##make sure that dataframe contains the right variables
# Set the most interesting contrast e.g. by defining synchronous or conversation as the baseline
# Model change as a function of own and other previous state 
# Bonus points: Add to the previous model also change in the other to see whether my adaptation is influenced by the other's adaptation.


##model notes from lecture
#Positive beta: The higher the state the more positive the change (and viceversa). pushing away from no change
#Negative beta: The higher the state the more negative the change (and viceversa). Pushing towards no change
#the change of heart rate over change of time for participant one= dx/dt
#the change of x from its baseline (0 is mean heart rate / reference heart rate / baseline) = d1(x* - xt) = x* is (as we scaled) 0 
#it becomes = dx/dt = b(-xt) + b2(yt) = b(-HR1) + b2(HR2) and dy/dt = b(-yt) + b2(xt) 
#metronome thing - the change of change

```

Long format and extra columns with change in HR and resp
```{r}

#generating new columns for previous HR and resps and change in HR and resp
mommy <- datty %>% group_by(group, condition, trial, study) %>% mutate(HR1 = HR1, HR2 = HR2, HR1_future = lead(HR1, 1), HR2_future = lead(HR2, 1), HR1_change = (HR1_future-HR1), HR2_change = (HR2_future-HR2), Resp1_future = lead(Resp1, n= 1), Resp2_future = lead(Resp2, 1), Resp1_change = (Resp1_future-Resp1), Resp2_change = (Resp2_future-Resp2))


#make it long format and group by a new column 

#for hr data
d_hr_change <- 
  gather(mommy, # data
         participant, HR_change_self, #new vars
         HR1_change, HR2_change) %>% #old vars
  select(#drop irrelevant vars
    time, HR_change_self, filename,
    study, group, condition, trial, participant) %>% 
  mutate(#create unique participant ID
    participant = parse_number(as.character(group))*10 + parse_number(participant))

d_hr_self <- 
  gather(mommy, # data
         participant, HR_self, #new vars
         HR1, HR2) %>% #old vars
  select(#drop irrelevant vars
    time, HR_self, filename,
    study, group, condition, trial, participant) %>% 
  mutate(#create unique participant ID
    participant = parse_number(as.character(group))*10 + parse_number(participant))



#for resp data
d_resp_change <- 
  gather(mommy, # data
         participant, Resp_change_self, #new vars
         Resp1_change, Resp2_change) %>% #old vars
  select(#drop irrelevant vars
    time, Resp_change_self, filename,
    study, group, condition, trial, participant) %>% 
  mutate(#create unique participant ID
    participant = parse_number(as.character(group))*10 + parse_number(participant))

d_resp_self <- 
  gather(mommy, # data
         participant, Resp_self, #new vars
         Resp1, Resp2) %>% #old vars
  select(#drop irrelevant vars
    time, Resp_self, filename,
    study, group, condition, trial, participant) %>% 
  mutate(#create unique participant ID
    participant = parse_number(as.character(group))*10 + parse_number(participant))


#merging to dataframe
grandma <- merge(d_hr_change, d_resp_change, all = T)
grandma <- merge(grandma, d_resp_self, all = T)
grandma <- merge(grandma, d_hr_self, all = T)




##### other #####

#doing the same as above but reversed for 1 and 2 so we can use it for columns with other person data 
cousin <- datty %>% group_by(group, condition, trial, study) %>% mutate(HR2_future = lead(HR1, n= 1), HR1_future = lead(HR2, 1), HR2_change = (HR1_future-HR1), HR1_change = (HR2_future-HR2), Resp2_future = lead(Resp1, n= 1), Resp1_future = lead(Resp2, 1), Resp2_change = (Resp1_future-Resp1), Resp1_change = (Resp2_future-Resp2), HR1_fake = HR2, HR2_fake = HR1, Resp1_fake = Resp2, Resp2_fake = Resp1)


#for hr data for other
d_hr_change_other <- 
  gather(cousin, # data
         participant, HR_change_other, #new vars
         HR1_change, HR2_change) %>% #old vars
  select(#drop irrelevant vars
    time, HR_change_other, filename,
    study, group, condition, trial, participant) %>% 
  mutate(#create unique participant ID
    participant = parse_number(as.character(group))*10 + parse_number(participant))

d_hr_other <- 
  gather(cousin, # data
         participant, HR_other, #new vars
         HR1_fake, HR2_fake) %>% #old vars
  select(#drop irrelevant vars
    time, HR_other, filename,
    study, group, condition, trial, participant) %>% 
  mutate(#create unique participant ID
    participant = parse_number(as.character(group))*10 + parse_number(participant))
save()


#for resp data for other
d_resp_change_other <- 
  gather(cousin, # data
         participant, Resp_change_other, #new vars
         Resp1_change, Resp2_change) %>% #old vars
  select(#drop irrelevant vars
    time, Resp_change_other, filename,
    study, group, condition, trial, participant) %>% 
  mutate(#create unique participant ID
    participant = parse_number(as.character(group))*10 + parse_number(participant))

d_resp_other <- 
  gather(cousin, # data
         participant, Resp_other, #new vars
         Resp1_fake, Resp2_fake) %>% #old vars
  select(#drop irrelevant vars
    time, Resp_other, filename,
    study, group, condition, trial, participant) %>% 
  mutate(#create unique participant ID
    participant = parse_number(as.character(group))*10 + parse_number(participant))

#merging to dataframe
grandpa <- merge(d_hr_change_other, d_resp_change_other, all = T)
grandpa <- merge(grandpa, d_resp_other, all = T)
grandpa <- merge(grandpa, d_hr_other, all = T)


#merging self and other
grandparents <- merge(grandpa, grandma, all = T)

```




Models
```{r}
# Set the most interesting contrast e.g. by defining synchronous or conversation as the baseline
table(grandparents$condition)
grandparents$condition <- factor(grandparents$condition)
#grandparents$condition <- relevel(grandparents$condition, ref = "S y")

#Single participant
part71 <- filter(grandparents, participant == "71") #dataframe with participant 71
glm(HR_change_self ~ 1 + HR_self + HR_other, family = gaussian, part71)
glm(HR_change_self ~ 1 + HR_self + HR_other:condition, family = gaussian, part71)
glm(HR_change_self ~ 1 + HR_self + HR_other*condition, family = gaussian, part71)

#Multiple participants
# Model change as a function of own and other previous state 

#first model 
m1 <- lmer(HR_change_self ~ 1 + (HR_self + HR_other) * condition + 
        (1 + (HR_self + HR_other) * condition|participant) + 
        (1 + (HR_self + HR_other) * condition|group), data = grandparents)

#first model but simple 
m2 <- lmer(HR_change_self ~ 1 + (HR_self + HR_other) * condition +  
             (1|participant) + 
             (1|group), data = grandparents)

#second model 
m3 <- lmer(HR_change_self ~ 0 + condition + (HR_self + HR_other):condition + 
        (0 + condition + (HR_self + HR_other):condition|participant) + 
        (0 + condition + (HR_self + HR_other):condition|group), data = grandparents)

#second model but simple
m4 <- lme4::lmer(HR_change_self ~ 0 + condition (HR_self + HR_other):condition + 
             (0 + condition|participant) + 
             (0 + condition|group), data = grandparents)


#summaries
summary(m2)
summary(m4)
 
```


## Now we need to create control baselines.

First shuffled controls, then surrogate pairs.

### Creating controls: shuffled controls

Shuffled controls break the temporal dependencies of time-series by shuffling the value within one time-series. This ensures the "coordination" observed is not due to the actual values in the series and not their sequence.
Tip: sample() is your friend, but make sure to shuffle things within participant/condition and not throughout the whole dataset
 
 Creating shuffled controls
```{r}

# Create a shuffled dataset
shuffled <- grandparents
shuffled$HR_self <-  sample(grandparents$HR_self)
shuffled$HR_other <-  sample(grandparents$HR_other)
shuffled$HR_lead <-  lead(shuffled$HR_self, 1)
shuffled$HR_change_self <-(shuffled$HR_lead - shuffled$HR_self)
shuffled$shuffle <- c(0)

     
# Concatenate it to the original dataset (and remember to have a column telling you which is which)

#adding extra stuff to grandparents
grandparents$HR_lead <-  lead(grandparents$HR_self, 1)
grandparents$shuffle <- c(1)

#merging
grand_shuf <- merge(shuffled, grandparents, all = T)


# Create the same models as in the previous chunk, but adding an interaction by shuffled vs. real

#first model 
shu1 <- lmer(HR_change_self ~ 1 + (HR_self + HR_other) * condition * shuffle + 
        (1 + (HR_self + HR_other) * condition * shuffle|participant) + 
        (1 + (HR_self + HR_other) * condition * shuffle|group), data = grand_shuf)

#first model but simple 
shu2 <- lmer(HR_change_self ~ 1 + (HR_self + HR_other) * condition * shuffle +  
             (1|participant) + 
             (1|group), data = grand_shuf)

summary(shu2)

#second model 
shu3 <- lmer(HR_change_self ~ 0 + condition + (HR_self + HR_other):condition:shuffle + 
        (0 + condition + (HR_self + HR_other):condition:shuffle|participant) + 
        (0 + condition + (HR_self + HR_other):condition:shuffle|group), data = grand_shuf)

#second model but simple
shu4 <- lme4::lmer(HR_change_self ~ 0 + condition + (HR_self + HR_other):condition:shuffle + 
             (0 + condition|participant) + 
             (0 + condition|group), data = grand_shuf)

summary(shu4)
p_load(lme4)
```
 
 
### TRICKY! Creating controls: surrogate pair controls
 - Per each real pair, identify at least one surrogate pair (matching one of the participants, with somebody doing the same task, but in a different pair)

Creating surrogate pair controls
```{r}

# Identify unique pairs within a given study (to keep things manageable) and create list of possible surrogate pairs (e.g. individual 1 from pair 1 and individual 2 from pair 2)

# Starting from the wide format, create "surrogate" dataset with the data from surrogate pairs

# Make it into long format

# Create models as in chunks above, but adding an interaction with the Real vs. Surrogate variable (exclude shuffled ones for simplicity)

groups <- as.numeric(as.character(unique(grandparents$group[grandparents$study==4]))) # List all pairs
surrogate_list <- expand.grid(a = groups, b = groups) # Identify all possible combinations of 2 pairs
surrogate_list <- subset(surrogate_list, a != b)  # exclude combinations with identical pairs

surrogate <- c()

for (i in 1:nrow(surrogate_list)){  # loop through all combinations
    x <- subset(grandparents, group==surrogate_list$a[i]) # subset data from the first pair
    y <- subset(grandparents, group==surrogate_list$a[i]) # subset data from the second pair   
    group <- c(800 + ((1:4)*i))                            # create new pair id
    for (co in c("Synchronous","TurnTaking","SelfPaced", "Conversation")){ # loop through conditions
       if (co %in% unique(x$condition) & co %in% unique(y$condition)){  # check both pairs have data 4 that condit.
           z1 <- subset(x, condition==co)            # subset only that condtion from first pair
           z2 <- subset(y, condition==co)            # subset only that condtion from second pair
           
           if (nrow(z1) > nrow(z2)) {	# make sure data have same length in both pairs
               z1<-z1[1:length(z2)]
            }          
           if (nrow(z2) > nrow(z1)) { 
               z2<-z2[1:length(z1)]
           }   
            w1 <- z1 %>% mutate(	# assemble new pair combining the 2 pairs
               HR2 = z2$HR2,
               Resp2 = z2$Resp2,
               HR2_lead = z2$HR2_lead,
               Resp2_lead = z2$Resp2_lead,
               HR2_change = z2$HR2_change, 
               Resp2_change = z2$Resp2_change)
            print(z1)
            print(z2)
            print(w1)
       } }}


```
 
```{r}
#loading gustavs data
sur_grandma<- read.csv("surrogate_grandma.csv")

#making column to indicate which is which in each dataframe before merging
sur_grandma$surrogate <- c(1)
stepgrandparents <-  grandparents
stepgrandparents$surrogate <- c(0) 

#merging
greatgrand <- merge(stepgrandparents, sur_grandma, all = T)


# Create the same models as in the previous chunk, but adding an interaction by surrogate vs. real
library("pacman")
p_load(lme4)
#first model 
sur1 <- lmer(HR_change_self ~ 1 + (HR_self + HR_other) * condition * surrogate + 
        (1 + (HR_self + HR_other) * condition * surrogate|participant) + 
        (1 + (HR_self + HR_other) * condition * surrogate|group), data = greatgrand)

#first model but simple 
sur2 <- lmer(HR_change_self ~ 1 + (HR_self + HR_other) * condition * surrogate +  
             (1|participant) + 
             (1|group), data = greatgrand)

summary(sur2)

#second model 
sur3 <- lmer(HR_change_self ~ 0 + condition + (HR_self + HR_other):condition:surrogate + 
        (0 + condition + (HR_self + HR_other):condition:surrogate|participant) + 
        (0 + condition + (HR_self + HR_other):condition:surrogate|group), data = greatgrand)

load("supermodels.rda")
summary(sur3)

#second model but simple
sur4 <- lmer(HR_change_self ~ 0 + condition + (HR_self + HR_other):condition:surrogate + 
             (0 + condition|participant) + 
             (0 + condition|group), data = greatgrand)

```

### Effects of respiration coordination on heart rate coordination
 - describe how you would test those.
 - Optional: run the models and report them

 